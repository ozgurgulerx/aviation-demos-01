name: Deploy Backend to AKS

on:
  push:
    branches: [main]
    paths:
      - 'src/**/*.py'
      - 'requirements.txt'
      - 'Dockerfile.backend'
      - 'k8s/**'
      - 'scripts/render-k8s-manifests.sh'
  workflow_dispatch:

concurrency:
  group: deploy-backend-${{ github.ref }}
  cancel-in-progress: false

permissions:
  id-token: write
  contents: read

env:
  AZURE_CONTAINER_REGISTRY_NAME: ${{ vars.AZURE_CONTAINER_REGISTRY_NAME || 'avrag705508acr' }}
  AZURE_CONTAINER_REGISTRY: ${{ vars.AZURE_CONTAINER_REGISTRY || 'avrag705508acr.azurecr.io' }}
  IMAGE_NAME: ${{ vars.BACKEND_IMAGE_NAME || 'aviation-rag-backend' }}
  IMAGE_TAG: ${{ github.sha }}
  AKS_CLUSTER: ${{ vars.AKS_CLUSTER || 'aks-aviation-rag' }}
  AKS_RESOURCE_GROUP: ${{ vars.AKS_RESOURCE_GROUP || 'rg-aviation-rag' }}
  K8S_NAMESPACE: ${{ vars.AKS_NAMESPACE || 'aviation-rag' }}

  AZURE_OPENAI_ENDPOINT: ${{ vars.AZURE_OPENAI_ENDPOINT }}
  AZURE_OPENAI_DEPLOYMENT_NAME: ${{ vars.AZURE_OPENAI_DEPLOYMENT_NAME || 'aviation-chat-gpt5-mini' }}
  AZURE_TEXT_EMBEDDING_DEPLOYMENT_NAME: ${{ vars.AZURE_TEXT_EMBEDDING_DEPLOYMENT_NAME || 'text-embedding-3-small' }}
  AZURE_SEARCH_ENDPOINT: ${{ vars.AZURE_SEARCH_ENDPOINT }}
  PII_ENDPOINT: ${{ vars.PII_ENDPOINT }}
  PII_CONTAINER_ENDPOINT: ${{ vars.PII_CONTAINER_ENDPOINT }}
  PGHOST: ${{ vars.PGHOST }}
  PGPORT: ${{ vars.PGPORT || '5432' }}
  PGDATABASE: ${{ vars.PGDATABASE || 'aviationrag' }}
  PGUSER: ${{ vars.PGUSER || 'aviationrag_readonly' }}
  FLASK_ENV: ${{ vars.FLASK_ENV || 'production' }}
  LOG_LEVEL: ${{ vars.LOG_LEVEL || 'INFO' }}
  USE_POSTGRES: ${{ vars.USE_POSTGRES || 'true' }}
  OTEL_SERVICE_NAME: ${{ vars.OTEL_SERVICE_NAME || 'aviation-rag-backend' }}
  ENVIRONMENT: ${{ vars.ENVIRONMENT || 'production' }}
  AF_SESSION_TTL_SECONDS: ${{ vars.AF_SESSION_TTL_SECONDS || '3600' }}
  AF_MAX_SESSIONS: ${{ vars.AF_MAX_SESSIONS || '500' }}
  AZURE_OPENAI_TIMEOUT_SECONDS: ${{ vars.AZURE_OPENAI_TIMEOUT_SECONDS || '45' }}
  AZURE_OPENAI_MAX_RETRIES: ${{ vars.AZURE_OPENAI_MAX_RETRIES || '1' }}
  GUNICORN_WORKER_CLASS: ${{ vars.GUNICORN_WORKER_CLASS || 'gthread' }}
  GUNICORN_WORKERS: ${{ vars.GUNICORN_WORKERS || '3' }}
  GUNICORN_THREADS: ${{ vars.GUNICORN_THREADS || '4' }}
  GUNICORN_TIMEOUT_SECONDS: ${{ vars.GUNICORN_TIMEOUT_SECONDS || '240' }}
  GUNICORN_GRACEFUL_TIMEOUT_SECONDS: ${{ vars.GUNICORN_GRACEFUL_TIMEOUT_SECONDS || '30' }}
  GUNICORN_KEEPALIVE_SECONDS: ${{ vars.GUNICORN_KEEPALIVE_SECONDS || '5' }}
  GUNICORN_MAX_REQUESTS: ${{ vars.GUNICORN_MAX_REQUESTS || '200' }}
  GUNICORN_MAX_REQUESTS_JITTER: ${{ vars.GUNICORN_MAX_REQUESTS_JITTER || '50' }}
  FABRIC_KQL_ENDPOINT: ${{ vars.FABRIC_KQL_ENDPOINT }}
  FABRIC_GRAPH_ENDPOINT: ${{ vars.FABRIC_GRAPH_ENDPOINT }}
  FABRIC_NOSQL_ENDPOINT: ${{ vars.FABRIC_NOSQL_ENDPOINT }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Azure (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Resolve ACR name
        run: |
          TARGET="${{ env.AZURE_CONTAINER_REGISTRY_NAME }}"
          REGISTRY_SERVER="${{ env.AZURE_CONTAINER_REGISTRY }}"
          FROM_SERVER="${REGISTRY_SERVER%%.*}"

          CANDIDATES=()
          [ -n "$TARGET" ] && CANDIDATES+=("$TARGET")
          [ -n "$FROM_SERVER" ] && CANDIDATES+=("$FROM_SERVER")
          CANDIDATES+=("avrag705508acr" "aviationragacr")

          UNIQUE=()
          for candidate in "${CANDIDATES[@]}"; do
            [ -n "$candidate" ] || continue
            skip=0
            for existing in "${UNIQUE[@]}"; do
              if [ "$existing" = "$candidate" ]; then
                skip=1
                break
              fi
            done
            [ "$skip" -eq 1 ] || UNIQUE+=("$candidate")
          done

          SELECTED=""
          for candidate in "${UNIQUE[@]}"; do
            if az acr show --name "$candidate" >/dev/null 2>&1; then
              SELECTED="$candidate"
              break
            fi
          done

          if [ -z "$SELECTED" ]; then
            echo "::error::Unable to resolve an accessible ACR from candidates: ${UNIQUE[*]}"
            echo "::group::ACRs visible to current Azure context"
            az acr list --query '[].name' -o tsv || true
            echo "::endgroup::"
            exit 1
          fi

          if [ "$SELECTED" != "$TARGET" ]; then
            echo "::warning::Configured AZURE_CONTAINER_REGISTRY_NAME '$TARGET' not found. Using '$SELECTED'."
          fi

          echo "Using ACR target: $SELECTED"
          echo "AZURE_CONTAINER_REGISTRY_NAME=$SELECTED" >> "$GITHUB_ENV"

      - name: Login to Azure Container Registry
        run: az acr login --name "${{ env.AZURE_CONTAINER_REGISTRY_NAME }}"

      - name: Resolve ACR login server
        run: |
          LOGIN_SERVER=$(az acr show --name "${{ env.AZURE_CONTAINER_REGISTRY_NAME }}" --query loginServer -o tsv)
          if [ -z "$LOGIN_SERVER" ]; then
            echo "::error::Unable to resolve login server for ACR '${{ env.AZURE_CONTAINER_REGISTRY_NAME }}'"
            exit 1
          fi
          echo "Resolved ACR login server: $LOGIN_SERVER"
          if [ "${{ env.AZURE_CONTAINER_REGISTRY }}" != "$LOGIN_SERVER" ]; then
            echo "::warning::Overriding AZURE_CONTAINER_REGISTRY='${{ env.AZURE_CONTAINER_REGISTRY }}' with '$LOGIN_SERVER'"
          fi
          echo "AZURE_CONTAINER_REGISTRY=$LOGIN_SERVER" >> "$GITHUB_ENV"

      - name: Build and push Docker image
        run: |
          docker build -f Dockerfile.backend -t "${{ env.AZURE_CONTAINER_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}" .
          docker tag "${{ env.AZURE_CONTAINER_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}" "${{ env.AZURE_CONTAINER_REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
          docker push "${{ env.AZURE_CONTAINER_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          docker push "${{ env.AZURE_CONTAINER_REGISTRY }}/${{ env.IMAGE_NAME }}:latest"

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Azure (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Resolve ACR name
        run: |
          TARGET="${{ env.AZURE_CONTAINER_REGISTRY_NAME }}"
          REGISTRY_SERVER="${{ env.AZURE_CONTAINER_REGISTRY }}"
          FROM_SERVER="${REGISTRY_SERVER%%.*}"

          CANDIDATES=()
          [ -n "$TARGET" ] && CANDIDATES+=("$TARGET")
          [ -n "$FROM_SERVER" ] && CANDIDATES+=("$FROM_SERVER")
          CANDIDATES+=("avrag705508acr" "aviationragacr")

          UNIQUE=()
          for candidate in "${CANDIDATES[@]}"; do
            [ -n "$candidate" ] || continue
            skip=0
            for existing in "${UNIQUE[@]}"; do
              if [ "$existing" = "$candidate" ]; then
                skip=1
                break
              fi
            done
            [ "$skip" -eq 1 ] || UNIQUE+=("$candidate")
          done

          SELECTED=""
          for candidate in "${UNIQUE[@]}"; do
            if az acr show --name "$candidate" >/dev/null 2>&1; then
              SELECTED="$candidate"
              break
            fi
          done

          if [ -z "$SELECTED" ]; then
            echo "::error::Unable to resolve an accessible ACR from candidates: ${UNIQUE[*]}"
            echo "::group::ACRs visible to current Azure context"
            az acr list --query '[].name' -o tsv || true
            echo "::endgroup::"
            exit 1
          fi

          if [ "$SELECTED" != "$TARGET" ]; then
            echo "::warning::Configured AZURE_CONTAINER_REGISTRY_NAME '$TARGET' not found. Using '$SELECTED'."
          fi

          echo "Using ACR target: $SELECTED"
          echo "AZURE_CONTAINER_REGISTRY_NAME=$SELECTED" >> "$GITHUB_ENV"

      - name: Validate required runtime variables
        run: |
          required=(AZURE_CONTAINER_REGISTRY_NAME AZURE_OPENAI_ENDPOINT AZURE_SEARCH_ENDPOINT PII_ENDPOINT PII_CONTAINER_ENDPOINT PGHOST)
          for var_name in "${required[@]}"; do
            if [ -z "${!var_name:-}" ]; then
              echo "::error::Missing required repository variable: ${var_name}"
              exit 1
            fi
          done

      - name: Resolve ACR login server
        run: |
          LOGIN_SERVER=$(az acr show --name "${{ env.AZURE_CONTAINER_REGISTRY_NAME }}" --query loginServer -o tsv)
          if [ -z "$LOGIN_SERVER" ]; then
            echo "::error::Unable to resolve login server for ACR '${{ env.AZURE_CONTAINER_REGISTRY_NAME }}'"
            exit 1
          fi
          echo "Resolved ACR login server: $LOGIN_SERVER"
          if [ "${{ env.AZURE_CONTAINER_REGISTRY }}" != "$LOGIN_SERVER" ]; then
            echo "::warning::Overriding AZURE_CONTAINER_REGISTRY='${{ env.AZURE_CONTAINER_REGISTRY }}' with '$LOGIN_SERVER'"
          fi
          echo "AZURE_CONTAINER_REGISTRY=$LOGIN_SERVER" >> "$GITHUB_ENV"

      - name: Get AKS credentials
        run: az aks get-credentials --resource-group "${{ env.AKS_RESOURCE_GROUP }}" --name "${{ env.AKS_CLUSTER }}" --overwrite-existing

      - name: Validate AKS can pull from ACR
        run: |
          check_acr_access() {
            local acr_name="$1"
            local output
            local status

            set +e
            output="$(az aks check-acr --resource-group "${{ env.AKS_RESOURCE_GROUP }}" --name "${{ env.AKS_CLUSTER }}" --acr "${acr_name}" 2>&1)"
            status=$?
            set -e

            echo "$output"

            if [ "$status" -ne 0 ]; then
              return 1
            fi

            if echo "$output" | grep -Eiq 'rejected token exchange|401|unauthorized|forbidden'; then
              return 1
            fi

            return 0
          }

          if check_acr_access "${{ env.AZURE_CONTAINER_REGISTRY_NAME }}"; then
            echo "USE_IMAGE_PULL_SECRET=false" >> "$GITHUB_ENV"
            exit 0
          fi

          echo "::warning::AKS cannot currently pull from ACR '${{ env.AZURE_CONTAINER_REGISTRY_NAME }}'. Attempting to attach ACR..."
          attach_output=""
          attach_status=0
          set +e
          attach_output="$(az aks update --resource-group "${{ env.AKS_RESOURCE_GROUP }}" --name "${{ env.AKS_CLUSTER }}" --attach-acr "${{ env.AZURE_CONTAINER_REGISTRY_NAME }}" 2>&1)"
          attach_status=$?
          set -e
          echo "$attach_output"

          echo "Re-checking AKS to ACR image pull permissions..."
          if [ "$attach_status" -eq 0 ] && check_acr_access "${{ env.AZURE_CONTAINER_REGISTRY_NAME }}"; then
            echo "USE_IMAGE_PULL_SECRET=false" >> "$GITHUB_ENV"
            exit 0
          fi

          echo "::warning::AKS kubelet identity still cannot pull from ACR '${{ env.AZURE_CONTAINER_REGISTRY_NAME }}'."
          echo "::warning::Falling back to acr-secret imagePullSecret for this deployment."
          echo "USE_IMAGE_PULL_SECRET=true" >> "$GITHUB_ENV"

      - name: Render Kubernetes manifests
        run: ./scripts/render-k8s-manifests.sh /tmp/k8s-rendered

      - name: Apply namespace and service manifests
        run: |
          kubectl apply -f /tmp/k8s-rendered/namespace.yaml
          kubectl apply -f /tmp/k8s-rendered/backend-service.yaml

      - name: Create or update backend secrets
        run: |
          kubectl create secret generic backend-secrets \
            --namespace="${{ env.K8S_NAMESPACE }}" \
            --from-literal=AZURE_OPENAI_API_KEY="${{ secrets.AZURE_OPENAI_API_KEY }}" \
            --from-literal=AZURE_SEARCH_ADMIN_KEY="${{ secrets.AZURE_SEARCH_ADMIN_KEY }}" \
            --from-literal=PGPASSWORD="${{ secrets.PGPASSWORD }}" \
            --from-literal=FABRIC_BEARER_TOKEN="${{ secrets.FABRIC_BEARER_TOKEN }}" \
            --from-literal=APPLICATIONINSIGHTS_CONNECTION_STRING="${{ secrets.APPLICATIONINSIGHTS_CONNECTION_STRING }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy backend manifests
        run: |
          kubectl apply -f /tmp/k8s-rendered/backend-configmap.yaml
          kubectl apply -f /tmp/k8s-rendered/backend-deployment.yaml

      - name: Configure backend image pull auth
        run: |
          if [ "${USE_IMAGE_PULL_SECRET:-false}" = "true" ]; then
            echo "::warning::Configuring acr-secret fallback image pull credentials."
            ACR_USERNAME="$(az acr credential show --name "${{ env.AZURE_CONTAINER_REGISTRY_NAME }}" --query username -o tsv)"
            ACR_PASSWORD="$(az acr credential show --name "${{ env.AZURE_CONTAINER_REGISTRY_NAME }}" --query 'passwords[0].value' -o tsv)"

            if [ -z "$ACR_USERNAME" ] || [ -z "$ACR_PASSWORD" ]; then
              echo "::error::Unable to retrieve ACR credentials for '${{ env.AZURE_CONTAINER_REGISTRY_NAME }}'."
              echo "::error::Enable ACR admin user or grant the workflow identity permission to list ACR credentials."
              exit 1
            fi

            kubectl create secret docker-registry acr-secret \
              --namespace="${{ env.K8S_NAMESPACE }}" \
              --docker-server="${{ env.AZURE_CONTAINER_REGISTRY }}" \
              --docker-username="$ACR_USERNAME" \
              --docker-password="$ACR_PASSWORD" \
              --dry-run=client -o yaml | kubectl apply -f -

            kubectl patch deployment aviation-rag-backend \
              --namespace="${{ env.K8S_NAMESPACE }}" \
              --type='merge' \
              -p '{"spec":{"template":{"spec":{"imagePullSecrets":[{"name":"acr-secret"}]}}}}'
            exit 0
          fi

          if kubectl get deployment aviation-rag-backend -n "${{ env.K8S_NAMESPACE }}" -o jsonpath='{.spec.template.spec.imagePullSecrets[*].name}' | grep -q .; then
            echo "::warning::Removing deployment imagePullSecrets to rely on AKS kubelet identity for ACR pulls."
            kubectl patch deployment aviation-rag-backend \
              --namespace="${{ env.K8S_NAMESPACE }}" \
              --type='json' \
              -p='[{"op":"remove","path":"/spec/template/spec/imagePullSecrets"}]'
          fi

          kubectl delete secret acr-secret --namespace="${{ env.K8S_NAMESPACE }}" --ignore-not-found

      - name: Stamp deployment with config and secret hashes
        run: |
          CONFIG_HASH=$(kubectl get configmap backend-config -n "${{ env.K8S_NAMESPACE }}" -o json | jq -cS '.data' | sha256sum | awk '{print $1}')
          SECRET_HASH=$(kubectl get secret backend-secrets -n "${{ env.K8S_NAMESPACE }}" -o json | jq -cS '.data' | sha256sum | awk '{print $1}')
          kubectl patch deployment aviation-rag-backend \
            --namespace="${{ env.K8S_NAMESPACE }}" \
            --type='merge' \
            -p "{\"spec\":{\"template\":{\"metadata\":{\"annotations\":{\"rollouts.codex.dev/config-hash\":\"${CONFIG_HASH}\",\"rollouts.codex.dev/secret-hash\":\"${SECRET_HASH}\"}}}}}"

      - name: Wait for rollout
        run: |
          timeout_seconds=900
          poll_interval=15
          deadline=$(( $(date +%s) + timeout_seconds ))
          expected_image="${{ env.AZURE_CONTAINER_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"
          tracked_generation="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.metadata.generation}' 2>/dev/null || echo 0)"
          drift_reapply_attempts=0
          max_drift_reapply_attempts=3
          use_pull_secret="${USE_IMAGE_PULL_SECRET:-false}"

          echo "Waiting for deployment to converge (image=${expected_image}, generation=${tracked_generation})"
          while [ "$(date +%s)" -lt "$deadline" ]; do
            desired="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.spec.replicas}' 2>/dev/null || echo 0)"
            current_generation="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.metadata.generation}' 2>/dev/null || echo 0)"
            observed_generation="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.status.observedGeneration}' 2>/dev/null || echo 0)"
            updated="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.status.updatedReplicas}' 2>/dev/null || echo 0)"
            available="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.status.availableReplicas}' 2>/dev/null || echo 0)"
            unavailable="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.status.unavailableReplicas}' 2>/dev/null || echo 0)"
            template_image="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.spec.template.spec.containers[?(@.name=="backend")].image}' 2>/dev/null || echo '')"
            template_pull_secrets="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.spec.template.spec.imagePullSecrets[*].name}' 2>/dev/null || echo '')"

            desired="${desired:-0}"
            current_generation="${current_generation:-0}"
            observed_generation="${observed_generation:-0}"
            updated="${updated:-0}"
            available="${available:-0}"
            unavailable="${unavailable:-0}"

            if [ "$template_image" != "$expected_image" ]; then
              drift_reapply_attempts=$((drift_reapply_attempts + 1))
              echo "::warning::Deployment template image drift detected during rollout."
              echo "::warning::Expected '$expected_image' but found '$template_image'. Re-applying expected image (attempt ${drift_reapply_attempts}/${max_drift_reapply_attempts})."

              kubectl set image deployment/aviation-rag-backend \
                backend="$expected_image" \
                --namespace="${{ env.K8S_NAMESPACE }}"

              tracked_generation="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.metadata.generation}' 2>/dev/null || echo "$tracked_generation")"

              if [ "$drift_reapply_attempts" -ge "$max_drift_reapply_attempts" ]; then
                echo "::error::Deployment image drift persisted after ${max_drift_reapply_attempts} re-apply attempts."
                exit 1
              fi

              sleep "$poll_interval"
              continue
            fi

            if [ "$use_pull_secret" = "true" ] && [ "$template_pull_secrets" != "acr-secret" ]; then
              drift_reapply_attempts=$((drift_reapply_attempts + 1))
              echo "::warning::Deployment auth drift detected during rollout."
              echo "::warning::Expected imagePullSecrets 'acr-secret' but found '$template_pull_secrets'. Re-applying fallback secret (attempt ${drift_reapply_attempts}/${max_drift_reapply_attempts})."

              kubectl patch deployment aviation-rag-backend \
                --namespace="${{ env.K8S_NAMESPACE }}" \
                --type='merge' \
                -p '{"spec":{"template":{"spec":{"imagePullSecrets":[{"name":"acr-secret"}]}}}}'

              tracked_generation="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.metadata.generation}' 2>/dev/null || echo "$tracked_generation")"

              if [ "$drift_reapply_attempts" -ge "$max_drift_reapply_attempts" ]; then
                echo "::error::Deployment auth drift persisted after ${max_drift_reapply_attempts} re-apply attempts."
                exit 1
              fi

              sleep "$poll_interval"
              continue
            fi

            if [ "$use_pull_secret" != "true" ] && [ -n "$template_pull_secrets" ]; then
              drift_reapply_attempts=$((drift_reapply_attempts + 1))
              echo "::warning::Deployment auth drift detected during rollout."
              echo "::warning::Unexpected imagePullSecrets '$template_pull_secrets'. Removing to keep AKS-managed ACR auth (attempt ${drift_reapply_attempts}/${max_drift_reapply_attempts})."

              kubectl patch deployment aviation-rag-backend \
                --namespace="${{ env.K8S_NAMESPACE }}" \
                --type='json' \
                -p='[{"op":"remove","path":"/spec/template/spec/imagePullSecrets"}]'
              kubectl delete secret acr-secret --namespace="${{ env.K8S_NAMESPACE }}" --ignore-not-found

              tracked_generation="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.metadata.generation}' 2>/dev/null || echo "$tracked_generation")"

              if [ "$drift_reapply_attempts" -ge "$max_drift_reapply_attempts" ]; then
                echo "::error::Deployment auth drift persisted after ${max_drift_reapply_attempts} re-apply attempts."
                exit 1
              fi

              sleep "$poll_interval"
              continue
            fi

            if [ "$current_generation" != "$tracked_generation" ]; then
              echo "::warning::Deployment generation changed from $tracked_generation to $current_generation while waiting. A concurrent restart/patch likely happened."
              tracked_generation="$current_generation"
            fi

            if [ "$observed_generation" -ge "$current_generation" ] && [ "$updated" -ge "$desired" ] && [ "$available" -ge "$desired" ] && [ "$unavailable" -eq 0 ]; then
              echo "Deployment converged (desired=$desired updated=$updated available=$available unavailable=$unavailable generation=$current_generation)."
              exit 0
            fi

            echo "Still converging: desired=$desired updated=$updated available=$available unavailable=$unavailable observedGeneration=$observed_generation generation=$current_generation"
            sleep "$poll_interval"
          done

          desired="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.spec.replicas}' 2>/dev/null || echo 0)"
          updated="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.status.updatedReplicas}' 2>/dev/null || echo 0)"
          available="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.status.availableReplicas}' 2>/dev/null || echo 0)"
          unavailable="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.status.unavailableReplicas}' 2>/dev/null || echo 0)"

          desired="${desired:-0}"
          updated="${updated:-0}"
          available="${available:-0}"
          unavailable="${unavailable:-0}"

          if [ "$updated" -ge "$desired" ] && [ "$available" -ge "$desired" ] && [ "$unavailable" -eq 0 ]; then
            echo "::warning::Rollout wait timed out but deployment is fully updated and available (desired=$desired updated=$updated available=$available unavailable=$unavailable). Continuing."
            exit 0
          fi

          echo "::error::Backend rollout timed out. Collecting diagnostics..."
          kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend || true
          kubectl get rs -n "${{ env.K8S_NAMESPACE }}" -l app=aviation-rag-backend || true
          kubectl get pods -n "${{ env.K8S_NAMESPACE }}" -l app=aviation-rag-backend -o wide || true
          kubectl get configmap backend-config -n "${{ env.K8S_NAMESPACE }}" -o yaml || true
          kubectl describe deployment aviation-rag-backend -n "${{ env.K8S_NAMESPACE }}" || true
          kubectl get events -n "${{ env.K8S_NAMESPACE }}" --sort-by=.lastTimestamp | tail -n 80 || true
          for pod in $(kubectl get pods -n "${{ env.K8S_NAMESPACE }}" -l app=aviation-rag-backend -o name); do
            echo "===== ${pod} ====="
            kubectl describe "${pod}" -n "${{ env.K8S_NAMESPACE }}" || true
            kubectl logs "${pod}" -n "${{ env.K8S_NAMESPACE }}" --tail=200 || true
            kubectl logs "${pod}" -n "${{ env.K8S_NAMESPACE }}" --previous --tail=200 || true
          done
          exit 1

      - name: Verify deployment
        run: |
          echo "Checking pod status..."
          kubectl get pods -n "${{ env.K8S_NAMESPACE }}" -l app=aviation-rag-backend
          echo "Checking service..."
          kubectl get svc -n "${{ env.K8S_NAMESPACE }}"
