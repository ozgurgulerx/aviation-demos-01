name: Deploy Backend to AKS

on:
  push:
    branches: [main]
    paths:
      - 'src/**/*.py'
      - 'requirements.txt'
      - 'Dockerfile.backend'
      - 'k8s/**'
      - 'scripts/render-k8s-manifests.sh'
  workflow_dispatch:

concurrency:
  group: deploy-backend-${{ github.ref }}
  cancel-in-progress: false

permissions:
  id-token: write
  contents: read

env:
  AZURE_CONTAINER_REGISTRY_NAME: ${{ vars.AZURE_CONTAINER_REGISTRY_NAME || 'avrag705508acr' }}
  AZURE_CONTAINER_REGISTRY: ${{ vars.AZURE_CONTAINER_REGISTRY || 'avrag705508acr.azurecr.io' }}
  IMAGE_NAME: ${{ vars.BACKEND_IMAGE_NAME || 'aviation-rag-backend' }}
  IMAGE_TAG: ${{ github.sha }}
  AKS_CLUSTER: ${{ vars.AKS_CLUSTER || 'aks-aviation-rag' }}
  AKS_RESOURCE_GROUP: ${{ vars.AKS_RESOURCE_GROUP || 'rg-aviation-rag' }}
  K8S_NAMESPACE: ${{ vars.AKS_NAMESPACE || 'aviation-rag' }}

  AZURE_OPENAI_ENDPOINT: ${{ vars.AZURE_OPENAI_ENDPOINT }}
  AZURE_OPENAI_DEPLOYMENT_NAME: ${{ vars.AZURE_OPENAI_DEPLOYMENT_NAME || 'aviation-chat-gpt5-mini' }}
  AZURE_TEXT_EMBEDDING_DEPLOYMENT_NAME: ${{ vars.AZURE_TEXT_EMBEDDING_DEPLOYMENT_NAME || 'text-embedding-3-small' }}
  AZURE_SEARCH_ENDPOINT: ${{ vars.AZURE_SEARCH_ENDPOINT }}
  PII_ENDPOINT: ${{ vars.PII_ENDPOINT }}
  PII_CONTAINER_ENDPOINT: ${{ vars.PII_CONTAINER_ENDPOINT }}
  PGHOST: ${{ vars.PGHOST }}
  PGPORT: ${{ vars.PGPORT || '5432' }}
  PGDATABASE: ${{ vars.PGDATABASE || 'aviationrag' }}
  PGUSER: ${{ vars.PGUSER || 'aviationrag_readonly' }}
  FLASK_ENV: ${{ vars.FLASK_ENV || 'production' }}
  LOG_LEVEL: ${{ vars.LOG_LEVEL || 'INFO' }}
  USE_POSTGRES: ${{ vars.USE_POSTGRES || 'true' }}
  OTEL_SERVICE_NAME: ${{ vars.OTEL_SERVICE_NAME || 'aviation-rag-backend' }}
  ENVIRONMENT: ${{ vars.ENVIRONMENT || 'production' }}
  AF_SESSION_TTL_SECONDS: ${{ vars.AF_SESSION_TTL_SECONDS || '3600' }}
  AF_MAX_SESSIONS: ${{ vars.AF_MAX_SESSIONS || '500' }}
  AZURE_OPENAI_TIMEOUT_SECONDS: ${{ vars.AZURE_OPENAI_TIMEOUT_SECONDS || '45' }}
  AZURE_OPENAI_MAX_RETRIES: ${{ vars.AZURE_OPENAI_MAX_RETRIES || '1' }}
  GUNICORN_WORKER_CLASS: ${{ vars.GUNICORN_WORKER_CLASS || 'gthread' }}
  GUNICORN_WORKERS: ${{ vars.GUNICORN_WORKERS || '3' }}
  GUNICORN_THREADS: ${{ vars.GUNICORN_THREADS || '4' }}
  GUNICORN_TIMEOUT_SECONDS: ${{ vars.GUNICORN_TIMEOUT_SECONDS || '240' }}
  GUNICORN_GRACEFUL_TIMEOUT_SECONDS: ${{ vars.GUNICORN_GRACEFUL_TIMEOUT_SECONDS || '30' }}
  GUNICORN_KEEPALIVE_SECONDS: ${{ vars.GUNICORN_KEEPALIVE_SECONDS || '5' }}
  GUNICORN_MAX_REQUESTS: ${{ vars.GUNICORN_MAX_REQUESTS || '200' }}
  GUNICORN_MAX_REQUESTS_JITTER: ${{ vars.GUNICORN_MAX_REQUESTS_JITTER || '50' }}
  FABRIC_KQL_ENDPOINT: ${{ vars.FABRIC_KQL_ENDPOINT }}
  FABRIC_GRAPH_ENDPOINT: ${{ vars.FABRIC_GRAPH_ENDPOINT }}
  FABRIC_NOSQL_ENDPOINT: ${{ vars.FABRIC_NOSQL_ENDPOINT }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Azure (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Resolve ACR name
        run: |
          TARGET="${{ env.AZURE_CONTAINER_REGISTRY_NAME }}"
          FALLBACK="avrag705508acr"

          if az acr show --name "$TARGET" >/dev/null 2>&1; then
            echo "Using ACR target: $TARGET"
            exit 0
          fi

          if [ "$TARGET" != "$FALLBACK" ] && az acr show --name "$FALLBACK" >/dev/null 2>&1; then
            echo "::warning::Configured AZURE_CONTAINER_REGISTRY_NAME '$TARGET' not found. Falling back to '$FALLBACK'."
            echo "AZURE_CONTAINER_REGISTRY_NAME=$FALLBACK" >> "$GITHUB_ENV"
            exit 0
          fi

          echo "::error::ACR '$TARGET' not found and fallback '$FALLBACK' unavailable."
          exit 1

      - name: Login to Azure Container Registry
        run: az acr login --name "${{ env.AZURE_CONTAINER_REGISTRY_NAME }}"

      - name: Resolve ACR login server
        run: |
          LOGIN_SERVER=$(az acr show --name "${{ env.AZURE_CONTAINER_REGISTRY_NAME }}" --query loginServer -o tsv)
          if [ -z "$LOGIN_SERVER" ]; then
            echo "::error::Unable to resolve login server for ACR '${{ env.AZURE_CONTAINER_REGISTRY_NAME }}'"
            exit 1
          fi
          echo "Resolved ACR login server: $LOGIN_SERVER"
          if [ "${{ env.AZURE_CONTAINER_REGISTRY }}" != "$LOGIN_SERVER" ]; then
            echo "::warning::Overriding AZURE_CONTAINER_REGISTRY='${{ env.AZURE_CONTAINER_REGISTRY }}' with '$LOGIN_SERVER'"
          fi
          echo "AZURE_CONTAINER_REGISTRY=$LOGIN_SERVER" >> "$GITHUB_ENV"

      - name: Build and push Docker image
        run: |
          docker build -f Dockerfile.backend -t "${{ env.AZURE_CONTAINER_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}" .
          docker tag "${{ env.AZURE_CONTAINER_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}" "${{ env.AZURE_CONTAINER_REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
          docker push "${{ env.AZURE_CONTAINER_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          docker push "${{ env.AZURE_CONTAINER_REGISTRY }}/${{ env.IMAGE_NAME }}:latest"

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Azure (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Resolve ACR name
        run: |
          TARGET="${{ env.AZURE_CONTAINER_REGISTRY_NAME }}"
          FALLBACK="avrag705508acr"

          if az acr show --name "$TARGET" >/dev/null 2>&1; then
            echo "Using ACR target: $TARGET"
            exit 0
          fi

          if [ "$TARGET" != "$FALLBACK" ] && az acr show --name "$FALLBACK" >/dev/null 2>&1; then
            echo "::warning::Configured AZURE_CONTAINER_REGISTRY_NAME '$TARGET' not found. Falling back to '$FALLBACK'."
            echo "AZURE_CONTAINER_REGISTRY_NAME=$FALLBACK" >> "$GITHUB_ENV"
            exit 0
          fi

          echo "::error::ACR '$TARGET' not found and fallback '$FALLBACK' unavailable."
          exit 1

      - name: Validate required runtime variables
        run: |
          required=(AZURE_CONTAINER_REGISTRY_NAME AZURE_OPENAI_ENDPOINT AZURE_SEARCH_ENDPOINT PII_ENDPOINT PII_CONTAINER_ENDPOINT PGHOST)
          for var_name in "${required[@]}"; do
            if [ -z "${!var_name:-}" ]; then
              echo "::error::Missing required repository variable: ${var_name}"
              exit 1
            fi
          done

      - name: Resolve ACR login server
        run: |
          LOGIN_SERVER=$(az acr show --name "${{ env.AZURE_CONTAINER_REGISTRY_NAME }}" --query loginServer -o tsv)
          if [ -z "$LOGIN_SERVER" ]; then
            echo "::error::Unable to resolve login server for ACR '${{ env.AZURE_CONTAINER_REGISTRY_NAME }}'"
            exit 1
          fi
          echo "Resolved ACR login server: $LOGIN_SERVER"
          if [ "${{ env.AZURE_CONTAINER_REGISTRY }}" != "$LOGIN_SERVER" ]; then
            echo "::warning::Overriding AZURE_CONTAINER_REGISTRY='${{ env.AZURE_CONTAINER_REGISTRY }}' with '$LOGIN_SERVER'"
          fi
          echo "AZURE_CONTAINER_REGISTRY=$LOGIN_SERVER" >> "$GITHUB_ENV"

      - name: Get AKS credentials
        run: az aks get-credentials --resource-group "${{ env.AKS_RESOURCE_GROUP }}" --name "${{ env.AKS_CLUSTER }}" --overwrite-existing

      - name: Validate AKS can pull from ACR
        run: |
          if az aks check-acr --resource-group "${{ env.AKS_RESOURCE_GROUP }}" --name "${{ env.AKS_CLUSTER }}" --acr "${{ env.AZURE_CONTAINER_REGISTRY_NAME }}"; then
            exit 0
          fi

          echo "::warning::AKS cannot currently pull from ACR '${{ env.AZURE_CONTAINER_REGISTRY_NAME }}'. Attempting to attach ACR..."
          az aks update --resource-group "${{ env.AKS_RESOURCE_GROUP }}" --name "${{ env.AKS_CLUSTER }}" --attach-acr "${{ env.AZURE_CONTAINER_REGISTRY_NAME }}"

          echo "Re-checking AKS to ACR image pull permissions..."
          if ! az aks check-acr --resource-group "${{ env.AKS_RESOURCE_GROUP }}" --name "${{ env.AKS_CLUSTER }}" --acr "${{ env.AZURE_CONTAINER_REGISTRY_NAME }}"; then
            echo "::error::AKS kubelet identity still cannot pull from ACR '${{ env.AZURE_CONTAINER_REGISTRY_NAME }}'."
            echo "::error::Verify ACR tenant/subscription alignment and AcrPull role assignments."
            exit 1
          fi

      - name: Render Kubernetes manifests
        run: ./scripts/render-k8s-manifests.sh /tmp/k8s-rendered

      - name: Apply namespace and service manifests
        run: |
          kubectl apply -f /tmp/k8s-rendered/namespace.yaml
          kubectl apply -f /tmp/k8s-rendered/backend-service.yaml

      - name: Create or update backend secrets
        run: |
          kubectl create secret generic backend-secrets \
            --namespace="${{ env.K8S_NAMESPACE }}" \
            --from-literal=AZURE_OPENAI_API_KEY="${{ secrets.AZURE_OPENAI_API_KEY }}" \
            --from-literal=AZURE_SEARCH_ADMIN_KEY="${{ secrets.AZURE_SEARCH_ADMIN_KEY }}" \
            --from-literal=PGPASSWORD="${{ secrets.PGPASSWORD }}" \
            --from-literal=FABRIC_BEARER_TOKEN="${{ secrets.FABRIC_BEARER_TOKEN }}" \
            --from-literal=APPLICATIONINSIGHTS_CONNECTION_STRING="${{ secrets.APPLICATIONINSIGHTS_CONNECTION_STRING }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy backend manifests
        run: |
          kubectl apply -f /tmp/k8s-rendered/backend-configmap.yaml
          kubectl apply -f /tmp/k8s-rendered/backend-deployment.yaml

      - name: Stamp deployment with config and secret hashes
        run: |
          CONFIG_HASH=$(kubectl get configmap backend-config -n "${{ env.K8S_NAMESPACE }}" -o json | jq -cS '.data' | sha256sum | awk '{print $1}')
          SECRET_HASH=$(kubectl get secret backend-secrets -n "${{ env.K8S_NAMESPACE }}" -o json | jq -cS '.data' | sha256sum | awk '{print $1}')
          kubectl patch deployment aviation-rag-backend \
            --namespace="${{ env.K8S_NAMESPACE }}" \
            --type='merge' \
            -p "{\"spec\":{\"template\":{\"metadata\":{\"annotations\":{\"rollouts.codex.dev/config-hash\":\"${CONFIG_HASH}\",\"rollouts.codex.dev/secret-hash\":\"${SECRET_HASH}\"}}}}}"

      - name: Wait for rollout
        run: |
          timeout_seconds=900
          poll_interval=15
          deadline=$(( $(date +%s) + timeout_seconds ))
          expected_image="${{ env.AZURE_CONTAINER_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"
          tracked_generation="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.metadata.generation}' 2>/dev/null || echo 0)"

          echo "Waiting for deployment to converge (image=${expected_image}, generation=${tracked_generation})"
          while [ "$(date +%s)" -lt "$deadline" ]; do
            desired="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.spec.replicas}' 2>/dev/null || echo 0)"
            current_generation="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.metadata.generation}' 2>/dev/null || echo 0)"
            observed_generation="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.status.observedGeneration}' 2>/dev/null || echo 0)"
            updated="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.status.updatedReplicas}' 2>/dev/null || echo 0)"
            available="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.status.availableReplicas}' 2>/dev/null || echo 0)"
            unavailable="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.status.unavailableReplicas}' 2>/dev/null || echo 0)"
            template_image="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.spec.template.spec.containers[?(@.name=="backend")].image}' 2>/dev/null || echo '')"

            desired="${desired:-0}"
            current_generation="${current_generation:-0}"
            observed_generation="${observed_generation:-0}"
            updated="${updated:-0}"
            available="${available:-0}"
            unavailable="${unavailable:-0}"

            if [ "$template_image" != "$expected_image" ]; then
              echo "::error::Deployment template image changed unexpectedly during rollout."
              echo "::error::Expected '$expected_image' but found '$template_image'."
              exit 1
            fi

            if [ "$current_generation" != "$tracked_generation" ]; then
              echo "::warning::Deployment generation changed from $tracked_generation to $current_generation while waiting. A concurrent restart/patch likely happened."
              tracked_generation="$current_generation"
            fi

            if [ "$observed_generation" -ge "$current_generation" ] && [ "$updated" -ge "$desired" ] && [ "$available" -ge "$desired" ] && [ "$unavailable" -eq 0 ]; then
              echo "Deployment converged (desired=$desired updated=$updated available=$available unavailable=$unavailable generation=$current_generation)."
              exit 0
            fi

            echo "Still converging: desired=$desired updated=$updated available=$available unavailable=$unavailable observedGeneration=$observed_generation generation=$current_generation"
            sleep "$poll_interval"
          done

          desired="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.spec.replicas}' 2>/dev/null || echo 0)"
          updated="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.status.updatedReplicas}' 2>/dev/null || echo 0)"
          available="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.status.availableReplicas}' 2>/dev/null || echo 0)"
          unavailable="$(kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend -o jsonpath='{.status.unavailableReplicas}' 2>/dev/null || echo 0)"

          desired="${desired:-0}"
          updated="${updated:-0}"
          available="${available:-0}"
          unavailable="${unavailable:-0}"

          if [ "$updated" -ge "$desired" ] && [ "$available" -ge "$desired" ] && [ "$unavailable" -eq 0 ]; then
            echo "::warning::Rollout wait timed out but deployment is fully updated and available (desired=$desired updated=$updated available=$available unavailable=$unavailable). Continuing."
            exit 0
          fi

          echo "::error::Backend rollout timed out. Collecting diagnostics..."
          kubectl get deploy -n "${{ env.K8S_NAMESPACE }}" aviation-rag-backend || true
          kubectl get rs -n "${{ env.K8S_NAMESPACE }}" -l app=aviation-rag-backend || true
          kubectl get pods -n "${{ env.K8S_NAMESPACE }}" -l app=aviation-rag-backend -o wide || true
          kubectl get configmap backend-config -n "${{ env.K8S_NAMESPACE }}" -o yaml || true
          kubectl describe deployment aviation-rag-backend -n "${{ env.K8S_NAMESPACE }}" || true
          kubectl get events -n "${{ env.K8S_NAMESPACE }}" --sort-by=.lastTimestamp | tail -n 80 || true
          for pod in $(kubectl get pods -n "${{ env.K8S_NAMESPACE }}" -l app=aviation-rag-backend -o name); do
            echo "===== ${pod} ====="
            kubectl describe "${pod}" -n "${{ env.K8S_NAMESPACE }}" || true
            kubectl logs "${pod}" -n "${{ env.K8S_NAMESPACE }}" --tail=200 || true
            kubectl logs "${pod}" -n "${{ env.K8S_NAMESPACE }}" --previous --tail=200 || true
          done
          exit 1

      - name: Verify deployment
        run: |
          echo "Checking pod status..."
          kubectl get pods -n "${{ env.K8S_NAMESPACE }}" -l app=aviation-rag-backend
          echo "Checking service..."
          kubectl get svc -n "${{ env.K8S_NAMESPACE }}"
